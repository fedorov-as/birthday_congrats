
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>birthday_congrats: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">birthday_congrats/cmd/birthday_congrats/main.go (0.0%)</option>
				
				<option value="file1">birthday_congrats/internal/pkg/alert_manager/alert_manager_mock.go (100.0%)</option>
				
				<option value="file2">birthday_congrats/internal/pkg/alert_manager/email_alert_manager.go (0.0%)</option>
				
				<option value="file3">birthday_congrats/internal/pkg/handlers/service.go (100.0%)</option>
				
				<option value="file4">birthday_congrats/internal/pkg/middlware/auth.go (0.0%)</option>
				
				<option value="file5">birthday_congrats/internal/pkg/middlware/logger.go (0.0%)</option>
				
				<option value="file6">birthday_congrats/internal/pkg/middlware/panic.go (0.0%)</option>
				
				<option value="file7">birthday_congrats/internal/pkg/session/manager_mock.go (0.0%)</option>
				
				<option value="file8">birthday_congrats/internal/pkg/session/mysql_manager.go (100.0%)</option>
				
				<option value="file9">birthday_congrats/internal/pkg/session/session.go (100.0%)</option>
				
				<option value="file10">birthday_congrats/internal/pkg/subscription/mysql_repo.go (100.0%)</option>
				
				<option value="file11">birthday_congrats/internal/pkg/subscription/repo_mock.go (0.0%)</option>
				
				<option value="file12">birthday_congrats/internal/pkg/user/mysql_repo.go (100.0%)</option>
				
				<option value="file13">birthday_congrats/internal/pkg/user/repo_mock.go (0.0%)</option>
				
				<option value="file14">birthday_congrats/internal/services/congrats_service/congrats_service_impl.go (96.1%)</option>
				
				<option value="file15">birthday_congrats/internal/services/congrats_service/congrats_service_mock.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        alertmanager "birthday_congrats/internal/pkg/alert_manager"
        "birthday_congrats/internal/pkg/handlers"
        "birthday_congrats/internal/pkg/middlware"
        "birthday_congrats/internal/pkg/session"
        "birthday_congrats/internal/pkg/subscription"
        "birthday_congrats/internal/pkg/user"
        service "birthday_congrats/internal/services/congrats_service"
        "context"
        "database/sql"
        "fmt"
        "html/template"
        "net/http"
        "sync"
        "time"

        "github.com/gorilla/mux"
        "go.uber.org/zap"
)

const (
        minutesBeforeStartAlerts = 5
        logoutTimeoutMinutes     = 60
        alertPeriodHours         = 24
)

func main() <span class="cov0" title="0">{
        templates := template.Must(template.ParseGlob("./templates/*"))

        // логгер
        zapLogger, err := zap.NewProduction()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error while creating zap logger: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                err = zapLogger.Sync()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error while zapLogger.Symc(): %v", err)
                }</span>
        }()
        <span class="cov0" title="0">logger := zapLogger.Sugar()

        // база данных
        dsn := "root:root@tcp(localhost:3306)/golang?" +
                "&amp;charset=utf8" +
                "&amp;interpolateParams=true"

        dbMySQL, err := sql.Open("mysql", dsn)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Cant open connection to usersDB: %v", err)
                return
        }</span>
        <span class="cov0" title="0">defer dbMySQL.Close()
        logger.Infow("Connected to MySQL database")

        dbMySQL.SetMaxOpenConns(10)

        err = dbMySQL.Ping()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("No connection to dbMySQL: %v", err)
                return
        }</span>

        // репозитории
        <span class="cov0" title="0">usersRepo := user.NewUsersMySQLRepo(
                dbMySQL,
                logger,
        )

        subscriptionsRepo := subscription.NewSubscriptionsMySQLRepo(
                dbMySQL,
                logger,
        )

        // менеджер сессий
        sm := session.NewMySQLSessionsManager(
                dbMySQL,
                logger,
                int64(time.Minute*logoutTimeoutMinutes/time.Second),
                16,
        )

        // менеджер отправки писем
        am := alertmanager.NewEmailAlertManager(
                // Информация об отправителе (в продакшене я бы закинул это в credentials на github/gitlab)
                "birthday.congratulations@yandex.ru",
                "ucgcgejoiguychfa",

                // smtp сервер конфигурация
                "smtp.yandex.ru",
                "587",
                logger,
        )

        // сам сервис
        service := service.NewCongratulationsServiceImpl(
                usersRepo,
                subscriptionsRepo,
                sm,
                am,
                logger,
        )

        // запускаем сервис оповещений
        ctx, cancel := context.WithCancel(context.Background())
        wg := &amp;sync.WaitGroup{}
        defer func() </span><span class="cov0" title="0">{
                cancel()
                wg.Wait()
        }</span>()

        <span class="cov0" title="0">wg.Add(1)
        go service.StartAlert(ctx, time.Now().Add(time.Minute*minutesBeforeStartAlerts), time.Hour*alertPeriodHours, wg)

        // хендлеры
        serviceHandler := handlers.NewServiceHandler(
                templates,
                service,
                sm,
                logger,
        )

        // роутер
        router := mux.NewRouter()
        router.HandleFunc("/", serviceHandler.Index).Methods("GET")
        router.HandleFunc("/register", serviceHandler.Register).Methods("POST")
        router.HandleFunc("/login", serviceHandler.Login).Methods("POST")
        router.HandleFunc("/error", serviceHandler.ErrorPage).Methods("GET")

        // хендлеры, требующие авторизации
        router.Handle("/users",
                middlware.Auth(sm, logger, http.HandlerFunc(serviceHandler.Users))).Methods("GET")
        router.Handle("/subscribe/{user_id}",
                middlware.Auth(sm, logger, http.HandlerFunc(serviceHandler.Subscribe))).Methods("POST")
        router.Handle("/unsubscribe/{user_id}",
                middlware.Auth(sm, logger, http.HandlerFunc(serviceHandler.Unsubscribe))).Methods("POST")
        router.Handle("/logout",
                middlware.Auth(sm, logger, http.HandlerFunc(serviceHandler.Logout))).Methods("GET")

        // добавляем миддлверы
        mux := middlware.Logger(logger, router)
        mux = middlware.Panic(logger, mux)

        // запуск сервера
        port := ":8080"
        logger.Infow("Starting server",
                "type", "START",
                "addr", port)
        err = http.ListenAndServe(port, mux)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Error while starting server",
                        "type", "ERROR",
                        "addr", port,
                        "error", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: alert_manager.go

// Package alertmanager is a generated GoMock package.
package alertmanager

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockAlertManager is a mock of AlertManager interface.
type MockAlertManager struct {
        ctrl     *gomock.Controller
        recorder *MockAlertManagerMockRecorder
}

// MockAlertManagerMockRecorder is the mock recorder for MockAlertManager.
type MockAlertManagerMockRecorder struct {
        mock *MockAlertManager
}

// NewMockAlertManager creates a new mock instance.
func NewMockAlertManager(ctrl *gomock.Controller) *MockAlertManager <span class="cov8" title="1">{
        mock := &amp;MockAlertManager{ctrl: ctrl}
        mock.recorder = &amp;MockAlertManagerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAlertManager) EXPECT() *MockAlertManagerMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Send mocks base method.
func (m *MockAlertManager) Send(to []string, subject, message string) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "Send", to, subject, message)
}</span>

// Send indicates an expected call of Send.
func (mr *MockAlertManagerMockRecorder) Send(to, subject, message interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Send", reflect.TypeOf((*MockAlertManager)(nil).Send), to, subject, message)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package alertmanager

import (
        "strings"

        "github.com/emersion/go-sasl"
        "github.com/emersion/go-smtp"

        "go.uber.org/zap"
)

type EmailAlertManager struct {
        auth     sasl.Client
        smtpHost string
        smtpPort string
        from     string
        logger   *zap.SugaredLogger
}

var _ AlertManager = &amp;EmailAlertManager{}

func NewEmailAlertManager(
        from string,
        password string,
        smtpHost string,
        smtpPort string,
        logger *zap.SugaredLogger,
) *EmailAlertManager <span class="cov0" title="0">{
        auth := sasl.NewPlainClient("", "birthday.congratulations@yandex.ru", "ucgcgejoiguychfa")

        return &amp;EmailAlertManager{
                auth:     auth,
                smtpHost: smtpHost,
                smtpPort: smtpPort,
                from:     from,
                logger:   logger,
        }
}</span>

func (am *EmailAlertManager) Send(to []string, subject, message string) <span class="cov0" title="0">{
        // Сообщение.
        msg := strings.NewReader(
                "From: " + am.from + "\r\n" +
                        "Subject: " + subject + "\r\n" +
                        "\r\n" +
                        message + "\r\n",
        )

        // Отправка почты.
        err := smtp.SendMail(am.smtpHost+":"+am.smtpPort, am.auth, am.from, to, msg)
        if err != nil </span><span class="cov0" title="0">{
                am.logger.Warnf("Error while sending emails: %v", err)
                return
        }</span>

        <span class="cov0" title="0">am.logger.Infof("Emails were sent to: %v", to)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "birthday_congrats/internal/pkg/session"
        "birthday_congrats/internal/pkg/user"
        service "birthday_congrats/internal/services/congrats_service"
        "html/template"
        "net/http"
        "strconv"
        "time"

        "github.com/gorilla/mux"
        "go.uber.org/zap"
)

type ServiceHandler struct {
        tmpl    *template.Template
        service service.CongratulationsService
        sm      session.SessionsManager
        logger  *zap.SugaredLogger
}

func NewServiceHandler(
        tmpl *template.Template,
        service service.CongratulationsService,
        sm session.SessionsManager,
        logger *zap.SugaredLogger,
) *ServiceHandler <span class="cov8" title="1">{
        return &amp;ServiceHandler{
                tmpl:    tmpl,
                service: service,
                sm:      sm,
                logger:  logger,
        }
}</span>

func (h *ServiceHandler) execErrorTemplate(w http.ResponseWriter, message string, statusCode int) <span class="cov8" title="1">{
        w.WriteHeader(statusCode)

        err := h.tmpl.ExecuteTemplate(w, "error.html", struct {
                Message string
        }{
                Message: message,
        })
        if err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusInternalServerError)
                h.logger.Errorf("Template error: %v", err)
        }</span>
}

func (h *ServiceHandler) Index(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        sess, err := h.sm.Check(r)
        if err == nil </span><span class="cov8" title="1">{
                ctx := session.ContextWithSession(r.Context(), sess)
                http.Redirect(w, r.WithContext(ctx), "/users", http.StatusFound)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)
        err = h.tmpl.ExecuteTemplate(w, "login.html", nil)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Errorf("template error: %v", err)
                http.Redirect(w, r, "/error", http.StatusFound)
        }</span>
}

func (h *ServiceHandler) ErrorPage(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        h.execErrorTemplate(w, "Произошла ошибка", http.StatusInternalServerError)
}</span>

func (h *ServiceHandler) Register(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        sess, err := h.service.Register(
                r.Context(),
                r.FormValue("username"),
                r.FormValue("password"),
                r.FormValue("email"),
                r.FormValue("birth"),
        )
        if err != nil &amp;&amp; err != user.ErrUserExists </span><span class="cov8" title="1">{
                h.logger.Errorf("Error while registration: %v", err)
                http.Redirect(w, r, "/error", http.StatusFound)
                return
        }</span>
        <span class="cov8" title="1">if err == user.ErrUserExists </span><span class="cov8" title="1">{
                h.execErrorTemplate(w, "Пользоваель с таким именем уже существует", http.StatusForbidden)
                return
        }</span>

        <span class="cov8" title="1">http.SetCookie(w, &amp;http.Cookie{
                Name:    "session_id",
                Value:   sess.SessID,
                Expires: time.Unix(sess.Expires, 0),
        })

        http.Redirect(w, r, "/users", http.StatusFound)</span>
}

func (h *ServiceHandler) Login(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        sess, err := h.service.Login(
                r.Context(),
                r.FormValue("username"),
                r.FormValue("password"),
        )
        if err != nil &amp;&amp; err != user.ErrNoUser </span><span class="cov8" title="1">{
                h.logger.Errorf("Error while registration: %v", err)
                http.Redirect(w, r, "/error", http.StatusFound)
                return
        }</span>
        <span class="cov8" title="1">if err == user.ErrNoUser </span><span class="cov8" title="1">{
                h.execErrorTemplate(w, "Неверный логин или пароль", http.StatusForbidden)
                return
        }</span>

        <span class="cov8" title="1">http.SetCookie(w, &amp;http.Cookie{
                Name:    "session_id",
                Value:   sess.SessID,
                Expires: time.Unix(sess.Expires, 0),
        })

        http.Redirect(w, r, "/users", http.StatusFound)</span>
}

func (h *ServiceHandler) Users(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        users, err := h.service.GetSubscriptionsByUser(r.Context())
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Errorf("Error getting all users: %v", err)
                http.Redirect(w, r, "/error", http.StatusFound)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)
        err = h.tmpl.ExecuteTemplate(w, "users.html", struct {
                Users []*user.User
        }{
                Users: users,
        })
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Errorf("Template error: %v", err)
                http.Redirect(w, r, "/error", http.StatusFound)
        }</span>
}

func (h *ServiceHandler) Subscribe(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        subscriptionID, err := strconv.Atoi(mux.Vars(r)["user_id"])
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Errorf("Error converting string to int: %v", err)
                http.Redirect(w, r, "/error", http.StatusFound)
                return
        }</span>

        <span class="cov8" title="1">daysAlert, err := strconv.Atoi(r.FormValue("days_alert"))
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Errorf("Error converting string to int: %v", err)
                http.Redirect(w, r, "/error", http.StatusFound)
                return
        }</span>

        <span class="cov8" title="1">err = h.service.Subscribe(r.Context(), uint32(subscriptionID), daysAlert)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Errorf("Error while subscribing: %v", err)
                http.Redirect(w, r, "/error", http.StatusFound)
                return
        }</span>

        <span class="cov8" title="1">http.Redirect(w, r, "/users", http.StatusFound)</span>
}

func (h *ServiceHandler) Unsubscribe(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        subscriptionID, err := strconv.Atoi(mux.Vars(r)["user_id"])
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Errorf("Error converting string to int: %v", err)
                http.Redirect(w, r, "/error", http.StatusFound)
                return
        }</span>

        <span class="cov8" title="1">err = h.service.Unsubscribe(r.Context(), uint32(subscriptionID))
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Errorf("Error while unsubscribing: %v", err)
                http.Redirect(w, r, "/error", http.StatusFound)
                return
        }</span>

        <span class="cov8" title="1">http.Redirect(w, r, "/users", http.StatusFound)</span>
}

func (h *ServiceHandler) Logout(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        err := h.service.Logout(r.Context())
        if err != nil &amp;&amp; err != session.ErrNotDestroyed </span><span class="cov8" title="1">{
                h.logger.Errorf("Error while logout: %v", err)
                http.Redirect(w, r, "/error", http.StatusFound)
                return
        }</span>
        <span class="cov8" title="1">if err == session.ErrNotDestroyed </span><span class="cov8" title="1">{
                h.logger.Warnf("Session was not destroyed")
        }</span>

        <span class="cov8" title="1">cookie, err := r.Cookie("session_id")
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Warnf("No cookie found")
                http.Redirect(w, r, "/error", http.StatusFound)
                return
        }</span>

        <span class="cov8" title="1">cookie.Expires = time.Now().AddDate(0, 0, -1)
        http.SetCookie(w, cookie)

        http.Redirect(w, r, "/", http.StatusFound)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package middlware

import (
        "birthday_congrats/internal/pkg/session"
        "net/http"

        "go.uber.org/zap"
)

func Auth(sm session.SessionsManager, logger *zap.SugaredLogger, next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                sess, err := sm.Check(r)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warnf("auth error: %v", err)
                        http.Redirect(w, r, "/error", http.StatusFound)
                        return
                }</span>

                <span class="cov0" title="0">ctx := session.ContextWithSession(r.Context(), sess)
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package middlware

import (
        "net/http"
        "time"

        "go.uber.org/zap"
)

func Logger(logger *zap.SugaredLogger, next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()
                next.ServeHTTP(w, r)

                logger.Infow("Request",
                        "method", r.Method,
                        "remote_address", r.RemoteAddr,
                        "url", r.URL.Path,
                        "duration", time.Since(start))
        }</span>)
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package middlware

import (
        "net/http"

        "go.uber.org/zap"
)

func Panic(logger *zap.SugaredLogger, next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                logger.Warnf("Panic recovered: %v", err)
                                http.Redirect(w, r, "/error", http.StatusInternalServerError)
                        }</span>
                }()
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: session.go

// Package session is a generated GoMock package.
package session

import (
        context "context"
        http "net/http"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockSessionsManager is a mock of SessionsManager interface.
type MockSessionsManager struct {
        ctrl     *gomock.Controller
        recorder *MockSessionsManagerMockRecorder
}

// MockSessionsManagerMockRecorder is the mock recorder for MockSessionsManager.
type MockSessionsManagerMockRecorder struct {
        mock *MockSessionsManager
}

// NewMockSessionsManager creates a new mock instance.
func NewMockSessionsManager(ctrl *gomock.Controller) *MockSessionsManager <span class="cov0" title="0">{
        mock := &amp;MockSessionsManager{ctrl: ctrl}
        mock.recorder = &amp;MockSessionsManagerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSessionsManager) EXPECT() *MockSessionsManagerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Check mocks base method.
func (m *MockSessionsManager) Check(r *http.Request) (*Session, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Check", r)
        ret0, _ := ret[0].(*Session)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Check indicates an expected call of Check.
func (mr *MockSessionsManagerMockRecorder) Check(r interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Check", reflect.TypeOf((*MockSessionsManager)(nil).Check), r)
}</span>

// Create mocks base method.
func (m *MockSessionsManager) Create(ctx context.Context, userID uint32) (*Session, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, userID)
        ret0, _ := ret[0].(*Session)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockSessionsManagerMockRecorder) Create(ctx, userID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockSessionsManager)(nil).Create), ctx, userID)
}</span>

// Destroy mocks base method.
func (m *MockSessionsManager) Destroy(ctx context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Destroy", ctx)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Destroy indicates an expected call of Destroy.
func (mr *MockSessionsManagerMockRecorder) Destroy(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Destroy", reflect.TypeOf((*MockSessionsManager)(nil).Destroy), ctx)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package session

import (
        "context"
        "database/sql"
        "fmt"
        "net/http"
        "time"

        _ "github.com/go-sql-driver/mysql"
        "go.uber.org/zap"
)

type MySQLSessionsManager struct {
        db     *sql.DB
        logger *zap.SugaredLogger

        expiresTime  int64
        sessIDLength int
}

var _ SessionsManager = &amp;MySQLSessionsManager{}

func NewMySQLSessionsManager(db *sql.DB, logger *zap.SugaredLogger, expiresTime int64, sessIDLength int) *MySQLSessionsManager <span class="cov8" title="1">{
        return &amp;MySQLSessionsManager{
                db:           db,
                logger:       logger,
                expiresTime:  expiresTime,
                sessIDLength: sessIDLength,
        }
}</span>

func (sm *MySQLSessionsManager) Create(ctx context.Context, userID uint32) (*Session, error) <span class="cov8" title="1">{
        newSession := newSession(sm.sessIDLength, userID, time.Now().Unix()+sm.expiresTime)

        result, err := sm.db.ExecContext(
                ctx,
                "INSERT INTO sessions (`sess_id`, `user_id`, `expires`) VALUES (?, ?, ?)",
                newSession.SessID,
                newSession.UserID,
                newSession.Expires,
        )
        if err != nil </span><span class="cov8" title="1">{
                sm.logger.Errorf("Error while INSERT into db: %v", err)
                return nil, fmt.Errorf("db error: %v", err)
        }</span>

        // проверка, что запись добавлена
        <span class="cov8" title="1">affected, err := result.RowsAffected()
        if err != nil </span><span class="cov8" title="1">{
                sm.logger.Errorf("Error in RowsAffected(): %v", err)
                return nil, fmt.Errorf("db error: %v", err)
        }</span>
        <span class="cov8" title="1">if affected == 0 </span><span class="cov8" title="1">{
                sm.logger.Errorf("Subscription was not added")
                return nil, ErrSessionNotCreated
        }</span>

        <span class="cov8" title="1">return &amp;newSession, nil</span>
}

func (sm *MySQLSessionsManager) Check(r *http.Request) (*Session, error) <span class="cov8" title="1">{
        cookie, err := r.Cookie("session_id")
        if err != nil </span><span class="cov8" title="1">{
                sm.logger.Warnf("No session cookie found")
                return nil, ErrNoSession
        }</span>

        <span class="cov8" title="1">sessID := cookie.Value

        // проверка, что сессия существует
        sess := &amp;Session{
                SessID: sessID,
        }
        err = sm.db.QueryRowContext(
                r.Context(),
                "SELECT user_id, expires FROM sessions WHERE sess_id = ?",
                sessID,
        ).Scan(
                &amp;sess.UserID,
                &amp;sess.Expires,
        )
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov8" title="1">{
                sm.logger.Errorf("Error while SELECT from db: %v", err)
                return nil, fmt.Errorf("db error: %v", err)
        }</span>
        <span class="cov8" title="1">if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                sm.logger.Warnf("No session found in db")
                return nil, ErrNoSession
        }</span>

        // проверка, что сессия не истекла
        <span class="cov8" title="1">if sess.Expires &lt; time.Now().Unix() </span><span class="cov8" title="1">{
                err := sm.Destroy(r.Context())
                if err != nil </span><span class="cov8" title="1">{
                        sm.logger.Errorf("Error while destroying session: %v", err)
                        return nil, fmt.Errorf("destroy session error: %v", err)
                }</span>

                <span class="cov8" title="1">return nil, ErrSessionExpired</span>
        }

        <span class="cov8" title="1">return sess, nil</span>
}

func (sm *MySQLSessionsManager) Destroy(ctx context.Context) error <span class="cov8" title="1">{
        sess, err := SessionFromContext(ctx)
        if err != nil </span><span class="cov8" title="1">{
                sm.logger.Errorf("Error getting session from context: %v", err)
                return ErrNoSession
        }</span>

        <span class="cov8" title="1">result, err := sm.db.ExecContext(
                ctx,
                "DELETE FROM sessions WHERE sess_id = ?",
                sess.SessID,
        )
        if err != nil </span><span class="cov8" title="1">{
                sm.logger.Errorf("Error while DELETE from db: %v", err)
                return fmt.Errorf("db error: %v", err)
        }</span>

        // проверка, что запись удалена
        <span class="cov8" title="1">affected, err := result.RowsAffected()
        if err != nil </span><span class="cov8" title="1">{
                sm.logger.Errorf("Error in RowsAffected(): %v", err)
                return fmt.Errorf("db error: %v", err)
        }</span>
        <span class="cov8" title="1">if affected == 0 </span><span class="cov8" title="1">{
                sm.logger.Errorf("Subscription was not added")
                return ErrNotDestroyed
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package session

import (
        "context"
        "math/rand"
        "net/http"

        "github.com/pkg/errors"
)

var (
        ErrSessionNotCreated = errors.New("session was not created")
        ErrNoSession         = errors.New("no session")
        ErrSessionExpired    = errors.New("session expired")
        ErrNotDestroyed      = errors.New("session was not destroyed")
)

type Session struct {
        SessID  string
        UserID  uint32
        Expires int64
}

type SessionsManager interface {
        Create(ctx context.Context, userID uint32) (*Session, error)
        Check(r *http.Request) (*Session, error)
        Destroy(ctx context.Context) error
}

func newSession(sessIDLength int, userID uint32, expires int64) Session <span class="cov8" title="1">{
        return Session{
                SessID:  RandStringRunes(sessIDLength),
                UserID:  userID,
                Expires: expires,
        }
}</span>

var (
        letterRunes = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
)

func RandStringRunes(n int) string <span class="cov8" title="1">{
        b := make([]rune, n)
        for i := range b </span><span class="cov8" title="1">{
                b[i] = letterRunes[rand.Intn(len(letterRunes))]
        }</span>
        <span class="cov8" title="1">return string(b)</span>
}

type sessKey string

const sessionKey sessKey = "sessionKey"

func ContextWithSession(ctx context.Context, sess *Session) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, sessionKey, sess)
}</span>

func SessionFromContext(ctx context.Context) (*Session, error) <span class="cov8" title="1">{
        sess, ok := ctx.Value(sessionKey).(*Session)
        if !ok || sess == nil </span><span class="cov8" title="1">{
                return nil, ErrNoSession
        }</span>

        <span class="cov8" title="1">return sess, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package subscription

import (
        "context"
        "database/sql"
        "fmt"

        _ "github.com/go-sql-driver/mysql"
        "go.uber.org/zap"
)

type SubscriptionsMySQLRepo struct {
        db     *sql.DB
        logger *zap.SugaredLogger
}

var _ SubscriptionsRepo = &amp;SubscriptionsMySQLRepo{}

func NewSubscriptionsMySQLRepo(db *sql.DB, logger *zap.SugaredLogger) *SubscriptionsMySQLRepo <span class="cov8" title="1">{
        return &amp;SubscriptionsMySQLRepo{
                db:     db,
                logger: logger,
        }
}</span>

func (repo *SubscriptionsMySQLRepo) GetAllSubscriptions(ctx context.Context) ([]*Subscription, error) <span class="cov8" title="1">{
        subscriptions := make([]*Subscription, 0, 10)

        rows, err := repo.db.QueryContext(
                ctx,
                "SELECT subscriber_id, subscription_id, days_alert FROM subscriptions",
        )
        if err != nil </span><span class="cov8" title="1">{
                repo.logger.Errorf("Error while SELECT from db: %v", err)
                return nil, fmt.Errorf("db error: %v", err)
        }</span>

        <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                subscr := &amp;Subscription{}
                err = rows.Scan(&amp;subscr.Subscriber, &amp;subscr.Subscription, &amp;subscr.DaysAlert)
                if err != nil </span><span class="cov8" title="1">{
                        repo.logger.Errorf("Error while scanning from sql row: %v", err)
                        return nil, fmt.Errorf("db error: %v", err)
                }</span>

                <span class="cov8" title="1">subscriptions = append(subscriptions, subscr)</span>
        }

        <span class="cov8" title="1">return subscriptions, nil</span>
}

func (repo *SubscriptionsMySQLRepo) GetSubscriptionsByUser(ctx context.Context, userID uint32) ([]*Subscription, error) <span class="cov8" title="1">{
        subscriptions := make([]*Subscription, 0, 10)

        rows, err := repo.db.QueryContext(
                ctx,
                "SELECT subscription_id, days_alert FROM subscriptions WHERE subscriber_id = ?",
                userID,
        )
        if err != nil </span><span class="cov8" title="1">{
                repo.logger.Errorf("Error while SELECT from db: %v", err)
                return nil, fmt.Errorf("db error: %v", err)
        }</span>

        <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                subscr := &amp;Subscription{
                        Subscriber: userID,
                }
                err = rows.Scan(&amp;subscr.Subscription, &amp;subscr.DaysAlert)
                if err != nil </span><span class="cov8" title="1">{
                        repo.logger.Errorf("Error while scanning from sql row: %v", err)
                        return nil, fmt.Errorf("db error: %v", err)
                }</span>

                <span class="cov8" title="1">subscriptions = append(subscriptions, subscr)</span>
        }

        <span class="cov8" title="1">return subscriptions, nil</span>
}

func (repo *SubscriptionsMySQLRepo) AddSubscription(ctx context.Context, subscriberID, subscriptionID uint32, daysAlert int) error <span class="cov8" title="1">{
        result, err := repo.db.ExecContext(
                ctx,
                "INSERT INTO subscriptions (`subscriber_id`, `subscription_id`, `days_alert`) VALUES (?, ?, ?)",
                subscriberID,
                subscriptionID,
                daysAlert,
        )
        if err != nil </span><span class="cov8" title="1">{
                repo.logger.Errorf("Error while INSERT into db: %v", err)
                return fmt.Errorf("db error: %v", err)
        }</span>

        // проверка, что запись добавлена
        <span class="cov8" title="1">affected, err := result.RowsAffected()
        if err != nil </span><span class="cov8" title="1">{
                repo.logger.Errorf("Error in RowsAffected(): %v", err)
                return fmt.Errorf("db error: %v", err)
        }</span>
        <span class="cov8" title="1">if affected == 0 </span><span class="cov8" title="1">{
                repo.logger.Errorf("Subscription was not added")
                return ErrAddSubscription
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (repo *SubscriptionsMySQLRepo) RemoveSubscription(ctx context.Context, subscriberID, subscriptionID uint32) error <span class="cov8" title="1">{
        result, err := repo.db.ExecContext(
                ctx,
                "DELETE FROM subscriptions WHERE subscriber_id = ? AND subscription_id = ?",
                subscriberID,
                subscriptionID,
        )
        if err != nil </span><span class="cov8" title="1">{
                repo.logger.Errorf("Error while DELETE from db: %v", err)
                return fmt.Errorf("db error: %v", err)
        }</span>

        // проверка, что запись удалена
        <span class="cov8" title="1">affected, err := result.RowsAffected()
        if err != nil </span><span class="cov8" title="1">{
                repo.logger.Errorf("Error in RowsAffected(): %v", err)
                return fmt.Errorf("db error: %v", err)
        }</span>
        <span class="cov8" title="1">if affected == 0 </span><span class="cov8" title="1">{
                repo.logger.Warnf("Subscription was not removed")
                return ErrRemoveSubscription
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: subscription.go

// Package subscription is a generated GoMock package.
package subscription

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockSubscriptionsRepo is a mock of SubscriptionsRepo interface.
type MockSubscriptionsRepo struct {
        ctrl     *gomock.Controller
        recorder *MockSubscriptionsRepoMockRecorder
}

// MockSubscriptionsRepoMockRecorder is the mock recorder for MockSubscriptionsRepo.
type MockSubscriptionsRepoMockRecorder struct {
        mock *MockSubscriptionsRepo
}

// NewMockSubscriptionsRepo creates a new mock instance.
func NewMockSubscriptionsRepo(ctrl *gomock.Controller) *MockSubscriptionsRepo <span class="cov0" title="0">{
        mock := &amp;MockSubscriptionsRepo{ctrl: ctrl}
        mock.recorder = &amp;MockSubscriptionsRepoMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSubscriptionsRepo) EXPECT() *MockSubscriptionsRepoMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// AddSubscription mocks base method.
func (m *MockSubscriptionsRepo) AddSubscription(ctx context.Context, subscriberID, subscriptionID uint32, daysAlert int) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddSubscription", ctx, subscriberID, subscriptionID, daysAlert)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// AddSubscription indicates an expected call of AddSubscription.
func (mr *MockSubscriptionsRepoMockRecorder) AddSubscription(ctx, subscriberID, subscriptionID, daysAlert interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddSubscription", reflect.TypeOf((*MockSubscriptionsRepo)(nil).AddSubscription), ctx, subscriberID, subscriptionID, daysAlert)
}</span>

// GetAllSubscriptions mocks base method.
func (m *MockSubscriptionsRepo) GetAllSubscriptions(ctx context.Context) ([]*Subscription, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllSubscriptions", ctx)
        ret0, _ := ret[0].([]*Subscription)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllSubscriptions indicates an expected call of GetAllSubscriptions.
func (mr *MockSubscriptionsRepoMockRecorder) GetAllSubscriptions(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllSubscriptions", reflect.TypeOf((*MockSubscriptionsRepo)(nil).GetAllSubscriptions), ctx)
}</span>

// GetSubscriptionsByUser mocks base method.
func (m *MockSubscriptionsRepo) GetSubscriptionsByUser(ctx context.Context, userID uint32) ([]*Subscription, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSubscriptionsByUser", ctx, userID)
        ret0, _ := ret[0].([]*Subscription)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetSubscriptionsByUser indicates an expected call of GetSubscriptionsByUser.
func (mr *MockSubscriptionsRepoMockRecorder) GetSubscriptionsByUser(ctx, userID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSubscriptionsByUser", reflect.TypeOf((*MockSubscriptionsRepo)(nil).GetSubscriptionsByUser), ctx, userID)
}</span>

// RemoveSubscription mocks base method.
func (m *MockSubscriptionsRepo) RemoveSubscription(ctx context.Context, subscriberID, subscriptionID uint32) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveSubscription", ctx, subscriberID, subscriptionID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveSubscription indicates an expected call of RemoveSubscription.
func (mr *MockSubscriptionsRepoMockRecorder) RemoveSubscription(ctx, subscriberID, subscriptionID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveSubscription", reflect.TypeOf((*MockSubscriptionsRepo)(nil).RemoveSubscription), ctx, subscriberID, subscriptionID)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package user

import (
        "context"
        "database/sql"
        "fmt"
        "sync"

        _ "github.com/go-sql-driver/mysql"
        "go.uber.org/zap"
)

type UsersMySQLRepo struct {
        mu     *sync.RWMutex
        db     *sql.DB
        logger *zap.SugaredLogger
}

var _ UsersRepo = &amp;UsersMySQLRepo{}

func NewUsersMySQLRepo(db *sql.DB, logger *zap.SugaredLogger) *UsersMySQLRepo <span class="cov8" title="1">{
        return &amp;UsersMySQLRepo{
                mu:     &amp;sync.RWMutex{},
                db:     db,
                logger: logger,
        }
}</span>

func (repo UsersMySQLRepo) Create(ctx context.Context, username, password, email string, year, month, day int) (*User, error) <span class="cov8" title="1">{
        // проверка, что пользователя с таким юзернэймом нет
        // сразу залочимся, чтобы никто не влез между запросами и не создал пользователя с таким же именем
        repo.mu.Lock()
        var id uint32
        err := repo.db.QueryRowContext(
                ctx,
                "SELECT id from users WHERE username = ?",
                username,
        ).Scan(&amp;id)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov8" title="1">{
                repo.mu.Unlock()
                repo.logger.Errorf("Error while SELECT from db: %v", err)
                return nil, fmt.Errorf("db error: %v", err)
        }</span>
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                repo.mu.Unlock()
                return nil, ErrUserExists
        }</span>

        <span class="cov8" title="1">result, err := repo.db.ExecContext(
                ctx,
                "INSERT INTO users (`username`, `password`, `email`, `year`, `month`, `day`) VALUES (?, ?, ?, ?, ?, ?)",
                username,
                password,
                email,
                year,
                month,
                day,
        )
        repo.mu.Unlock()

        if err != nil </span><span class="cov8" title="1">{
                repo.logger.Errorf("Error while INSERT into db: %v", err)
                return nil, fmt.Errorf("db error: %v", err)
        }</span>

        // проверка, что запись добавлена
        <span class="cov8" title="1">affected, err := result.RowsAffected()
        if err != nil </span><span class="cov8" title="1">{
                repo.logger.Errorf("Error in RowsAffected(): %v", err)
                return nil, fmt.Errorf("db error: %v", err)
        }</span>
        <span class="cov8" title="1">if affected == 0 </span><span class="cov8" title="1">{
                repo.logger.Errorf("User with username `%d` was not created", username)
                return nil, ErrUserNotCreated
        }</span>

        <span class="cov8" title="1">lastID, err := result.LastInsertId()
        if err != nil </span><span class="cov8" title="1">{
                repo.logger.Errorf("Error in LastInsertedId(): %v", err)
                return nil, fmt.Errorf("db error: %v", err)
        }</span>

        <span class="cov8" title="1">newUser := &amp;User{
                ID:       uint32(lastID),
                Username: username,
                Email:    email,
                Year:     year,
                Month:    month,
                Day:      day,
        }

        return newUser, nil</span>
}

func (repo *UsersMySQLRepo) Login(ctx context.Context, username, password string) (*User, error) <span class="cov8" title="1">{
        user := &amp;User{}
        var passwordInDB string

        err := repo.db.QueryRowContext(
                ctx,
                "SELECT id, username, password, email, year, month, day FROM users WHERE username = ?",
                username,
        ).Scan(
                &amp;user.ID,
                &amp;user.Username,
                &amp;passwordInDB,
                &amp;user.Email,
                &amp;user.Year,
                &amp;user.Month,
                &amp;user.Day,
        )
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov8" title="1">{
                repo.logger.Errorf("Error while SELECT from db: %v", err)
                return nil, fmt.Errorf("db error: %v", err)
        }</span>
        <span class="cov8" title="1">if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, ErrNoUser
        }</span>

        <span class="cov8" title="1">if password != passwordInDB </span><span class="cov8" title="1">{
                return nil, ErrBadPassword
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

func (repo *UsersMySQLRepo) GetAll(ctx context.Context) ([]*User, error) <span class="cov8" title="1">{
        users := make([]*User, 0, 10)

        rows, err := repo.db.QueryContext(
                ctx,
                "SELECT id, username, email, year, month, day FROM users",
        )
        if err != nil </span><span class="cov8" title="1">{
                repo.logger.Errorf("Error while SELECT from db: %v", err)
                return nil, fmt.Errorf("db error: %v", err)
        }</span>

        <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                user := &amp;User{}
                err = rows.Scan(
                        &amp;user.ID,
                        &amp;user.Username,
                        &amp;user.Email,
                        &amp;user.Year,
                        &amp;user.Month,
                        &amp;user.Day,
                )
                if err != nil </span><span class="cov8" title="1">{
                        repo.logger.Errorf("Error while scanning from sql row: %v", err)
                        return nil, fmt.Errorf("db error: %v", err)
                }</span>

                <span class="cov8" title="1">users = append(users, user)</span>
        }

        <span class="cov8" title="1">return users, nil</span>
}

func (repo *UsersMySQLRepo) GetByID(ctx context.Context, userID uint32) (*User, error) <span class="cov8" title="1">{
        user := &amp;User{}

        err := repo.db.QueryRowContext(
                ctx,
                "SELECT id, username, email, year, month, day FROM users WHERE id = ?",
                userID,
        ).Scan(
                &amp;user.ID,
                &amp;user.Username,
                &amp;user.Email,
                &amp;user.Year,
                &amp;user.Month,
                &amp;user.Day,
        )
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov8" title="1">{
                repo.logger.Errorf("Error while SELECT from db: %v", err)
                return nil, fmt.Errorf("db error: %v", err)
        }</span>
        <span class="cov8" title="1">if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, ErrNoUser
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: user.go

// Package user is a generated GoMock package.
package user

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockUsersRepo is a mock of UsersRepo interface.
type MockUsersRepo struct {
        ctrl     *gomock.Controller
        recorder *MockUsersRepoMockRecorder
}

// MockUsersRepoMockRecorder is the mock recorder for MockUsersRepo.
type MockUsersRepoMockRecorder struct {
        mock *MockUsersRepo
}

// NewMockUsersRepo creates a new mock instance.
func NewMockUsersRepo(ctrl *gomock.Controller) *MockUsersRepo <span class="cov0" title="0">{
        mock := &amp;MockUsersRepo{ctrl: ctrl}
        mock.recorder = &amp;MockUsersRepoMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUsersRepo) EXPECT() *MockUsersRepoMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockUsersRepo) Create(ctx context.Context, username, password, email string, year, month, day int) (*User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, username, password, email, year, month, day)
        ret0, _ := ret[0].(*User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockUsersRepoMockRecorder) Create(ctx, username, password, email, year, month, day interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockUsersRepo)(nil).Create), ctx, username, password, email, year, month, day)
}</span>

// GetAll mocks base method.
func (m *MockUsersRepo) GetAll(ctx context.Context) ([]*User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAll", ctx)
        ret0, _ := ret[0].([]*User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAll indicates an expected call of GetAll.
func (mr *MockUsersRepoMockRecorder) GetAll(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAll", reflect.TypeOf((*MockUsersRepo)(nil).GetAll), ctx)
}</span>

// GetByID mocks base method.
func (m *MockUsersRepo) GetByID(ctx context.Context, userID uint32) (*User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByID", ctx, userID)
        ret0, _ := ret[0].(*User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByID indicates an expected call of GetByID.
func (mr *MockUsersRepoMockRecorder) GetByID(ctx, userID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*MockUsersRepo)(nil).GetByID), ctx, userID)
}</span>

// Login mocks base method.
func (m *MockUsersRepo) Login(ctx context.Context, username, password string) (*User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Login", ctx, username, password)
        ret0, _ := ret[0].(*User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Login indicates an expected call of Login.
func (mr *MockUsersRepoMockRecorder) Login(ctx, username, password interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Login", reflect.TypeOf((*MockUsersRepo)(nil).Login), ctx, username, password)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package congrats_service

import (
        alertmanager "birthday_congrats/internal/pkg/alert_manager"
        "birthday_congrats/internal/pkg/session"
        "birthday_congrats/internal/pkg/subscription"
        "birthday_congrats/internal/pkg/user"
        "context"
        "fmt"
        "slices"
        "sync"
        "time"

        "github.com/pkg/errors"
        "go.uber.org/zap"
)

const (
        dateLayout = "2006-01-02"
)

var (
        ErrBadDateFormat = errors.New("bad date format")
)

type CongratulationsServiceImpl struct {
        usersRepo         user.UsersRepo
        subscriptionsRepo subscription.SubscriptionsRepo
        sm                session.SessionsManager
        alerts            alertmanager.AlertManager
        logger            *zap.SugaredLogger
}

var _ CongratulationsService = &amp;CongratulationsServiceImpl{}

func NewCongratulationsServiceImpl(
        usersRepo user.UsersRepo,
        subscriptionsRepo subscription.SubscriptionsRepo,
        sm session.SessionsManager,
        alerts alertmanager.AlertManager,
        logger *zap.SugaredLogger,
) *CongratulationsServiceImpl <span class="cov8" title="1">{
        return &amp;CongratulationsServiceImpl{
                usersRepo:         usersRepo,
                subscriptionsRepo: subscriptionsRepo,
                sm:                sm,
                alerts:            alerts,
                logger:            logger,
        }
}</span>

func (cs *CongratulationsServiceImpl) Register(ctx context.Context, username, password, email, birth string) (*session.Session, error) <span class="cov8" title="1">{
        birthday, err := time.Parse(dateLayout, birth)
        if err != nil </span><span class="cov8" title="1">{
                cs.logger.Errorf("Error while parsing date: %v", err)
                return nil, ErrBadDateFormat
        }</span>

        <span class="cov8" title="1">newUser, err := cs.usersRepo.Create(
                ctx,
                username,
                password,
                email,
                birthday.Year(),
                int(birthday.Month()),
                birthday.Day(),
        )
        if err != nil &amp;&amp; err != user.ErrUserExists </span><span class="cov8" title="1">{
                cs.logger.Errorf("Error while creating user: %v", err)
                return nil, fmt.Errorf("internal error")
        }</span>
        <span class="cov8" title="1">if err == user.ErrUserExists </span><span class="cov8" title="1">{
                cs.logger.Warnf("User already exists")
                return nil, err
        }</span>

        <span class="cov8" title="1">sess, err := cs.sm.Create(ctx, newUser.ID)
        if err != nil </span><span class="cov8" title="1">{
                cs.logger.Errorf("Error while creating session")
                return nil, fmt.Errorf("internal error")
        }</span>

        <span class="cov8" title="1">return sess, nil</span>
}

func (cs *CongratulationsServiceImpl) Login(ctx context.Context, username, password string) (*session.Session, error) <span class="cov8" title="1">{
        us, err := cs.usersRepo.Login(ctx, username, password)
        if err != nil &amp;&amp; err != user.ErrNoUser &amp;&amp; err != user.ErrBadPassword </span><span class="cov8" title="1">{
                cs.logger.Errorf("Error while logging in: %v", err)
                return nil, fmt.Errorf("internal error")
        }</span>
        <span class="cov8" title="1">if err == user.ErrNoUser || err == user.ErrBadPassword </span><span class="cov8" title="1">{
                cs.logger.Warnf("User not exist: %v", err)
                return nil, user.ErrNoUser // оставляем только один тип ошибки, чтобы мошеннику было сложнее подобрать пароль
        }</span>

        <span class="cov8" title="1">sess, err := cs.sm.Create(ctx, us.ID)
        if err != nil </span><span class="cov8" title="1">{
                cs.logger.Errorf("Error while creating session")
                return nil, fmt.Errorf("internal error")
        }</span>

        <span class="cov8" title="1">return sess, nil</span>
}

func (cs *CongratulationsServiceImpl) Subscribe(ctx context.Context, subscriptionID uint32, daysAlert int) error <span class="cov8" title="1">{
        sess, err := session.SessionFromContext(ctx)
        if err != nil </span><span class="cov8" title="1">{
                cs.logger.Errorf("Error getting session from context: %v", err)
                return err
        }</span>

        <span class="cov8" title="1">err = cs.subscriptionsRepo.AddSubscription(ctx, sess.UserID, subscriptionID, daysAlert)
        if err != nil &amp;&amp; err != subscription.ErrAddSubscription </span><span class="cov8" title="1">{
                cs.logger.Errorf("Error adding subscription: %v", err)
                return fmt.Errorf("Internal error")
        }</span>
        <span class="cov8" title="1">if err == subscription.ErrAddSubscription </span><span class="cov8" title="1">{
                cs.logger.Warnf("Subscription was not added")
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (cs *CongratulationsServiceImpl) Unsubscribe(ctx context.Context, subscriptionID uint32) error <span class="cov8" title="1">{
        sess, err := session.SessionFromContext(ctx)
        if err != nil </span><span class="cov8" title="1">{
                cs.logger.Errorf("Error getting session from context: %v", err)
                return err
        }</span>

        <span class="cov8" title="1">err = cs.subscriptionsRepo.RemoveSubscription(ctx, sess.UserID, subscriptionID)
        if err != nil &amp;&amp; err != subscription.ErrRemoveSubscription </span><span class="cov8" title="1">{
                cs.logger.Errorf("Error removing subscription: %v", err)
                return fmt.Errorf("Internal error")
        }</span>
        <span class="cov8" title="1">if err == subscription.ErrRemoveSubscription </span><span class="cov8" title="1">{
                cs.logger.Warnf("Subscription was not removed")
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (cs *CongratulationsServiceImpl) Logout(ctx context.Context) error <span class="cov8" title="1">{
        err := cs.sm.Destroy(ctx)
        if err != nil &amp;&amp; err != session.ErrNotDestroyed &amp;&amp; err != session.ErrNoSession </span><span class="cov8" title="1">{
                cs.logger.Errorf("Error while destroying session")
                return fmt.Errorf("internal error")
        }</span>
        <span class="cov8" title="1">if err == session.ErrNoSession || err == session.ErrNotDestroyed </span><span class="cov8" title="1">{
                cs.logger.Warnf("Session was not destroyed")
                return session.ErrNotDestroyed
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (cs *CongratulationsServiceImpl) GetSubscriptionsByUser(ctx context.Context) ([]*user.User, error) <span class="cov8" title="1">{
        sess, err := session.SessionFromContext(ctx)
        if err != nil </span><span class="cov8" title="1">{
                cs.logger.Errorf("Error getting session from context: %v", err)
                return nil, session.ErrNoSession
        }</span>

        <span class="cov8" title="1">users, err := cs.usersRepo.GetAll(ctx)
        if err != nil </span><span class="cov8" title="1">{
                cs.logger.Errorf("Error while getting all users: %v", err)
                return nil, fmt.Errorf("internal error")
        }</span>

        <span class="cov8" title="1">subscriptions, err := cs.subscriptionsRepo.GetSubscriptionsByUser(ctx, sess.UserID)
        if err != nil </span><span class="cov8" title="1">{
                cs.logger.Errorf("Error getting subscriptions: %v", err)
                return nil, fmt.Errorf("internal error")
        }</span>

        <span class="cov8" title="1">slices.SortFunc(subscriptions, func(a, b *subscription.Subscription) int </span><span class="cov8" title="1">{ return int(a.Subscription) - int(b.Subscription) }</span>)

        <span class="cov8" title="1">i := 0
        for _, u := range users </span><span class="cov8" title="1">{
                if i &gt;= len(subscriptions) </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">if u.ID == subscriptions[i].Subscription </span><span class="cov8" title="1">{
                        u.Subscription = true
                        u.DaysAlert = subscriptions[i].DaysAlert
                        i++
                }</span>
        }

        <span class="cov8" title="1">return users, nil</span>
}

func (cs *CongratulationsServiceImpl) StartAlert(ctx context.Context, timeStart time.Time, period time.Duration, wg *sync.WaitGroup) <span class="cov0" title="0">{
        if timeStart.After(time.Now()) </span><span class="cov0" title="0">{
                cs.logger.Infof("Alert service will start at %v", timeStart)
                time.Sleep(time.Until(timeStart))
        }</span>

        <span class="cov0" title="0">cs.logger.Infof("Starting alert service")
        go cs.alert(ctx, period, wg)</span>
}

func (cs *CongratulationsServiceImpl) alert(ctx context.Context, period time.Duration, wg *sync.WaitGroup) <span class="cov8" title="1">{
        defer wg.Done()

        cs.logger.Infof("Alert service started")

        ticker := time.NewTicker(period)
        defer ticker.Stop()

        // первый раз делаем отправку сразу, затем по тикеру
        messages, recipients, err := cs.makeMessages(ctx)
        if err != nil </span><span class="cov8" title="1">{
                cs.logger.Errorf("Error while making messages: %v", err)
                return
        }</span>

        <span class="cov8" title="1">cs.logger.Infof("Sending %d different messages today", len(messages))

        for i := range messages </span><span class="cov8" title="1">{
                cs.alerts.Send(recipients[i], "Напоминание о дне рождения!", messages[i])
        }</span>

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        cs.logger.Infof("Alert service was stopped")
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        messages, recipients, err := cs.makeMessages(ctx)
                        if err != nil </span><span class="cov8" title="1">{
                                cs.logger.Errorf("Error while making messages: %v", err)
                                continue</span>
                        }

                        <span class="cov8" title="1">cs.logger.Infof("Sending %d different messages today", len(messages))

                        for i := range messages </span><span class="cov8" title="1">{
                                cs.alerts.Send(recipients[i], "Напоминание о дне рождения!", messages[i])
                        }</span>
                }
        }
}

func (cs *CongratulationsServiceImpl) makeMessages(ctx context.Context) ([]string, [][]string, error) <span class="cov8" title="1">{
        subscriptions, err := cs.subscriptionsRepo.GetAllSubscriptions(ctx)
        if err != nil </span><span class="cov8" title="1">{
                cs.logger.Errorf("Error getting all subscriptions: %v", err)
                return nil, nil, fmt.Errorf("error getting subscriptions from repo")
        }</span>

        <span class="cov8" title="1">if len(subscriptions) == 0 </span><span class="cov8" title="1">{
                return nil, nil, nil
        }</span>

        <span class="cov8" title="1">slices.SortStableFunc(subscriptions, func(a, b *subscription.Subscription) int </span><span class="cov8" title="1">{ return int(a.Subscription) - int(b.Subscription) }</span>)

        <span class="cov8" title="1">messages := make([]string, 0)
        recipients := make([][]string, 0)

        var subID uint32
        var daysBefore int
        to := make([]string, 0)

        for i, sub := range subscriptions </span><span class="cov8" title="1">{
                if sub.Subscription != subID || i == 0 </span><span class="cov8" title="1">{
                        subID = sub.Subscription
                        us, err := cs.usersRepo.GetByID(ctx, subID)
                        if err != nil </span><span class="cov8" title="1">{
                                cs.logger.Errorf("Error getting user by id: %v", err)
                                return nil, nil, fmt.Errorf("repo error: %v", err)
                        }</span>

                        <span class="cov8" title="1">birthday := time.Date(
                                time.Now().Year(),
                                time.Month(us.Month),
                                us.Day,
                                0, 0, 0, 0,
                                time.Local,
                        )
                        if birthday.Before(time.Now()) </span><span class="cov8" title="1">{
                                birthday = birthday.AddDate(1, 0, 0)
                        }</span>

                        <span class="cov8" title="1">if len(to) &gt; 0 </span><span class="cov8" title="1">{
                                recipients = append(recipients, to)
                        }</span> else<span class="cov8" title="1"> if len(messages) &gt; 0 </span><span class="cov8" title="1">{
                                messages = messages[:len(messages)-1]
                        }</span>

                        <span class="cov8" title="1">daysBefore = int(time.Until(birthday).Hours())/24 + 1
                        messages = append(messages, fmt.Sprintf("%s празднует свой день рождения через %d дней!", us.Username, daysBefore))

                        to = make([]string, 0)</span>
                }

                <span class="cov8" title="1">if daysBefore == sub.DaysAlert </span><span class="cov8" title="1">{
                        subscriber, err := cs.usersRepo.GetByID(ctx, sub.Subscriber)
                        if err != nil </span><span class="cov8" title="1">{
                                cs.logger.Errorf("Error getting user by id: %v", err)
                                return nil, nil, fmt.Errorf("repo error: %v", err)
                        }</span>

                        <span class="cov8" title="1">to = append(to, subscriber.Email)</span>
                }
        }

        <span class="cov8" title="1">if len(to) &gt; 0 </span><span class="cov0" title="0">{
                recipients = append(recipients, to)
        }</span> else<span class="cov8" title="1"> if len(messages) &gt; 0 </span><span class="cov8" title="1">{
                messages = messages[:len(messages)-1]
        }</span>

        <span class="cov8" title="1">return messages, recipients, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: congrats_service.go

// Package congrats_service is a generated GoMock package.
package congrats_service

import (
        session "birthday_congrats/internal/pkg/session"
        user "birthday_congrats/internal/pkg/user"
        context "context"
        reflect "reflect"
        sync "sync"
        time "time"

        gomock "github.com/golang/mock/gomock"
)

// MockCongratulationsService is a mock of CongratulationsService interface.
type MockCongratulationsService struct {
        ctrl     *gomock.Controller
        recorder *MockCongratulationsServiceMockRecorder
}

// MockCongratulationsServiceMockRecorder is the mock recorder for MockCongratulationsService.
type MockCongratulationsServiceMockRecorder struct {
        mock *MockCongratulationsService
}

// NewMockCongratulationsService creates a new mock instance.
func NewMockCongratulationsService(ctrl *gomock.Controller) *MockCongratulationsService <span class="cov0" title="0">{
        mock := &amp;MockCongratulationsService{ctrl: ctrl}
        mock.recorder = &amp;MockCongratulationsServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCongratulationsService) EXPECT() *MockCongratulationsServiceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetSubscriptionsByUser mocks base method.
func (m *MockCongratulationsService) GetSubscriptionsByUser(ctx context.Context) ([]*user.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSubscriptionsByUser", ctx)
        ret0, _ := ret[0].([]*user.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetSubscriptionsByUser indicates an expected call of GetSubscriptionsByUser.
func (mr *MockCongratulationsServiceMockRecorder) GetSubscriptionsByUser(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSubscriptionsByUser", reflect.TypeOf((*MockCongratulationsService)(nil).GetSubscriptionsByUser), ctx)
}</span>

// Login mocks base method.
func (m *MockCongratulationsService) Login(ctx context.Context, username, password string) (*session.Session, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Login", ctx, username, password)
        ret0, _ := ret[0].(*session.Session)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Login indicates an expected call of Login.
func (mr *MockCongratulationsServiceMockRecorder) Login(ctx, username, password interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Login", reflect.TypeOf((*MockCongratulationsService)(nil).Login), ctx, username, password)
}</span>

// Logout mocks base method.
func (m *MockCongratulationsService) Logout(ctx context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Logout", ctx)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Logout indicates an expected call of Logout.
func (mr *MockCongratulationsServiceMockRecorder) Logout(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Logout", reflect.TypeOf((*MockCongratulationsService)(nil).Logout), ctx)
}</span>

// Register mocks base method.
func (m *MockCongratulationsService) Register(ctx context.Context, username, password, email, birth string) (*session.Session, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Register", ctx, username, password, email, birth)
        ret0, _ := ret[0].(*session.Session)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Register indicates an expected call of Register.
func (mr *MockCongratulationsServiceMockRecorder) Register(ctx, username, password, email, birth interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Register", reflect.TypeOf((*MockCongratulationsService)(nil).Register), ctx, username, password, email, birth)
}</span>

// StartAlert mocks base method.
func (m *MockCongratulationsService) StartAlert(ctx context.Context, timeStart time.Time, period time.Duration, wg *sync.WaitGroup) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "StartAlert", ctx, timeStart, period, wg)
}</span>

// StartAlert indicates an expected call of StartAlert.
func (mr *MockCongratulationsServiceMockRecorder) StartAlert(ctx, timeStart, period, wg interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartAlert", reflect.TypeOf((*MockCongratulationsService)(nil).StartAlert), ctx, timeStart, period, wg)
}</span>

// Subscribe mocks base method.
func (m *MockCongratulationsService) Subscribe(ctx context.Context, subscriptionID uint32, daysAlert int) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Subscribe", ctx, subscriptionID, daysAlert)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Subscribe indicates an expected call of Subscribe.
func (mr *MockCongratulationsServiceMockRecorder) Subscribe(ctx, subscriptionID, daysAlert interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockCongratulationsService)(nil).Subscribe), ctx, subscriptionID, daysAlert)
}</span>

// Unsubscribe mocks base method.
func (m *MockCongratulationsService) Unsubscribe(ctx context.Context, subscriptionID uint32) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Unsubscribe", ctx, subscriptionID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Unsubscribe indicates an expected call of Unsubscribe.
func (mr *MockCongratulationsServiceMockRecorder) Unsubscribe(ctx, subscriptionID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unsubscribe", reflect.TypeOf((*MockCongratulationsService)(nil).Unsubscribe), ctx, subscriptionID)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
